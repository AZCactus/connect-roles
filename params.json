{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# Connect Roles\r\n\r\nConnect roles is designed to work with connect or express.  It is an authorization provider, not an authentication provider.  It is designed to support context sensitive roles/abilities, through the use of middleware style authentication strategies.\r\n\r\nAll code samples assume you have already used:\r\n\r\n```javascript\r\nvar app = require('express').createServer();//could also use connect\r\nvar user = require('connect-roles');\r\n\r\napp.use(/* Your authentication middleware goes here */);\r\napp.use(user);//Load the connect-roles middleware here\r\n```\r\n\r\nFor an example of this in use, see server.js (which requires you install express)\r\n\r\n## Installation\r\n\r\n    npm install connect-roles\r\n\r\n## Authorization\r\n\r\nConnect Roles assumes that you have authentication middleware to set the user.  It expects the user to be on the request object as `req.user`.  It makes no assumptions about what this value contains.  If this value is not used, it does not matter as the authentication strategies also have access to the request object itself\r\n\r\n## Defining authentication strategies\r\n\r\nTo define authentication strategies, call the useAuthorisationStrategy function:\r\n\r\n@param [path] {string}   The action/path/ability/role that this strategy applies to.  The strategy will be ignored for all other roles/abilities.  If it is not present, the strategy is used for all roles/abilities.  \r\n@param fn     {function} The function to call to determine whether the user is authorized.  \r\n@param fn.this           {object}   The value of this inside the function is the current request, useful for dynamic authorization.  \r\n@param fn.user           {object}   The user found at req.user (also available as this.user), note that this could be null/undefined if the user is not authenticated.  \r\n@param fn.action         {string}   The action/role/ability etc. that we are checking permission for.  \r\n@param fn.stop           {function} A function which can be called with or without the vote to make this the last strategy which is used (see anonymous example).  \r\n@param [fn.stop.vote]         {boolean} The vote, true, false or null as below.  \r\n@param [fn.returns vote] {boolean}  The function can optionally return a vote, if this is false, then access will be denied, if this is true and nothing returns false, access will be granted.  \r\n \r\n```javascript\r\nuser.useAuthorisationStrategy(function(user, action, stop){\r\n  //User logic here.\r\n});\r\n\r\n//Or\r\n\r\nuser.useAuthorisationStrategy(\"create user\", function(user, action, stop){\r\n  //User logic here.\r\n});\r\n```\r\n\r\n### Anonymous User\r\n\r\nYou should probably handle anonymous users first.  This is important because it means you then won't have to handle anonymous users individually in every other function, providing you call stop.\r\n\r\nIf you have anything that an anonymous user is capeable of, you must then check before checking for \"anonymous\".\r\n\r\n```javascript\r\nuser.useAuthorisationStrategy(\"register\", function(user){\r\n  if(!user.isAuthenticated) return true;\r\n});\r\n\r\nuser.useAuthorisationStrategy(function(user, action, stop){\r\n  if(!user.isAuthenticated){\r\n    stop(action === \"anonymous\");\r\n  }\r\n});\r\n```\r\n\r\n### Roles\r\n\r\nIf you have a user object which looks like `{id:10, roles:[\"RoleA\", \"RoleB\"]}` you could use the following to provide roles checking.\r\n\r\n```javascript\r\nuser.useAuthorisationStrategy(function(user, action){\r\n  if(user.isAuthenticated){//You can remove this if already checking for anonymous users\r\n    for(var i = 0; i<user.roles.length; i++){\r\n      if(user.roles[i] === action) return true;\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n### Dynamic\r\n\r\nThis example is what makes this library special.\r\n\r\n```javascript\r\nuser.useAuthorisationStrategy(\"edit user\", function(user, action){\r\n  if(user.isAuthenticated){//You can remove this if already checking for anonymous users\r\n    if(req.params.userid){\r\n      if(user.id === req.params.userid){\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\n//Then you can use the following in express\r\napp.get('/user/:userid/edit', user.can(\"edit user\"), function(req,res){\r\n  //Only called if the user is editing themselves, not other people.\r\n});\r\n```\r\n\r\n## Inline authorization for connect or express\r\n\r\nProviding you have supplied the middleware (see the first section of this guide) you can use the following functions.\r\n\r\n### req.isAuthenticated\r\n\r\nThis is a property that is either true or false to tell you whether the user object is present.\r\n\r\n### req.userIs, req.userCan, req.user.can, req.user.is\r\n\r\nThese functions are all the same, but be aware that methods of the form req.user.* will throw exceptions if user is null.\r\n\r\n```javascript\r\napp.get(\"/canifly\", function(req,res){\r\n  if(req.userCan(\"fly\")) res.send(\"You can fly\");\r\n  else res.send(\"You can't fly\");\r\n});\r\n\r\napp.get(\"/logout\", function(req,res){\r\n    //Note how we check authenticated first.\r\n  if(req.isAuthenticated && req.user.can(\"logout\")){\r\n    logout();\r\n  }else{\r\n    throw \"user can't log out\";\r\n  }\r\n});\r\n```\r\n\r\n## Route middleware for express\r\n\r\nIn express you can provide route middleware.  This is perfect for authentication, especially with wildcards.\r\n\r\n\r\n### Protect entire admin section in one line\r\n\r\nSimply put this before you have any other routes beginning /admin\r\n\r\n```javascript\r\napp.get(\"/admin*\", user.is(\"admin\"));\r\n\r\n```\r\n\r\n### Only let people edit themselves\r\n\r\n```javascript\r\nuser.useAuthorisationStrategy(\"edit user\", function(user, action){\r\n  if(user.isAuthenticated){//You can remove this if already checking for anonymous users\r\n    if(req.params.userid){\r\n      if(user.id === req.params.userid){\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\n//Then you can use the following in express\r\napp.get('/user/:userid/edit', user.can(\"edit user\"), function(req,res){\r\n  //Only called if the user is editing themselves, not other people.\r\n});\r\n```\r\n\r\n### Chain things\r\n\r\n```javascript\r\nuser.useAuthorisationStrategy(\"register\", function(user){\r\n  if(!user.isAuthenticated) return true;\r\n});\r\n\r\nuser.useAuthorisationStrategy(function(user, action, stop){\r\n  if(!user.isAuthenticated){\r\n    stop(action === \"anonymous\");\r\n  }\r\n});\r\n\r\napp.get(\"/register\", user.is(\"anonymous\"), user.can(\"register\"), function(req,res){\r\n  //Only called if the user can register.\r\n});\r\n```\r\n\r\n## Failure handler\r\n\r\nYou can (and should) set the failure handler.  This is called whenever a user fails authorization in route middleware.\r\n\r\nIt is set as follows:\r\n\r\n```javascript\r\nuser.setFailureHandler(function (req, res, action){\r\n  res.send(403);\r\n});\r\n```\r\n\r\nThat, incidentally is the default implimentation.  There is no \"next\" by design, to stop you accidentally calling it and allowing someone into a restricted part of your site.  You are passed the action/role/ability which caused them to be denied access.\r\n\r\n### Redirect on failure\r\n\r\nYou should probably consider using this to redirect the user, something like:\r\n\r\n```javascript\r\nuser.setFailureHandler(function (req, res, action){\r\n  if(req.user){\r\n    res.redirect('/accessdenied?reason=' + action);\r\n  } else {\r\n    res.redirect('/login');\r\n  }\r\n});\r\n```\r\n\r\n## Default User\r\n\r\nBy default, the user middleware will set the user up to be `{}` and will then add the property `isAuthenticated = false`.\r\n\r\nRoles will always add `isAuthenticated = false` but you can configure a default user object as follows.\r\n\r\n```javascript\r\nuser.setDefaultUser({id:\"anonymous\"});\r\n```","google":"UA-34130504-1","name":"Connect-roles","tagline":"Provides dynamic roles based authentication for node.js connect and express servers."}